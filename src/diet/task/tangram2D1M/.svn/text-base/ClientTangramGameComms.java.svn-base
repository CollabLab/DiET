/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package diet.task.tangram2D1M;

/**
 *
 * @author user
 */
import java.util.Date;
import java.util.Vector;

import javax.swing.SwingUtilities;

import diet.client.ConnectionToServer;
import diet.message.MessageTask;
import diet.task.ClientTaskEventHandler;
import diet.task.tangram2D1M.message.MessageEndOfCurTangramSet;
import diet.task.tangram2D1M.message.MessageEndOfGame;
import diet.task.tangram2D1M.message.MessageNewTangrams;
import diet.task.tangram2D1M.message.MessageNewTangramsDirectorA;
import diet.task.tangram2D1M.message.MessageNewTangramsDirectorB;
import diet.task.tangram2D1M.message.MessageNewTangramsMatcher;
import diet.task.tangram2D1M.message.MessageNextTangramPlaced;
import diet.task.tangram2D1M.message.MessageStartGame;
import diet.task.tangram2D1M.message.MessageTangramRevealed;



/**
 * This deals with events generated by the maze game, local client keyboard input and maze game messages received
 * from the server.
 * <p>It unpacks messages from the server and generates messages to be sent to the server. 
 * 
 *
 * @author user
 */
public class ClientTangramGameComms extends ClientTaskEventHandler {
    
 
  TangramFrame tangramFrame;
 
 
  String dispMessage = null;
  
  Date timeOfLastKeyPress = new Date();

  public ClientTangramGameComms(ConnectionToServer cts, MessageNewTangrams mnt){
      super(cts);
      System.out.println("initialising clienttangramgame");
      try{
          if (mnt instanceof MessageNewTangramsMatcher)
          {
              MessageNewTangramsMatcher mntm=(MessageNewTangramsMatcher)mnt;
              Vector<SerialTangram> tangrams=mntm.tangrams;
              String setName=mntm.tangramSetName;
              tangramFrame=new MatcherTangramFrame(tangrams, setName);
              tangramFrame.setTitle(mntm.nameOfRecipient);
          }
          else if (mnt instanceof MessageNewTangramsDirectorA)
          {
              MessageNewTangramsDirectorA mnta=(MessageNewTangramsDirectorA)mnt;
              Vector<SerialTangram> tangrams=mnta.tangrams;
              String setName=mnta.tangramSetName;
              TangramSequence sequence=mnta.sequence;
              tangramFrame=new DirectorTangramFrame(sequence, 'A', tangrams, setName);
              tangramFrame.setTitle(mnta.nameOfRecipient);
              
              
          }
          else if (mnt instanceof MessageNewTangramsDirectorB)
          {
              MessageNewTangramsDirectorB mntb=(MessageNewTangramsDirectorB)mnt;
              Vector<SerialTangram> tangrams=mntb.tangrams;
              String setName=mntb.tangramSetName;
              TangramSequence sequence=mntb.sequence;
              tangramFrame=new DirectorTangramFrame(sequence, 'B', tangrams, setName);
              tangramFrame.setTitle(mntb.nameOfRecipient);
              
          }
        
        tangramFrame.setComms(this);
       
        tangramFrame.setVisible(true);
        tangramFrame.enableFrame();
     
        
       
        
      }catch (Exception e){
          System.err.println(e.getMessage().toString());
          System.out.println("STACKTRACE:");
          e.printStackTrace();
      }  
  }
  
  public void repaintTangramFrame(){
      try{
            SwingUtilities.invokeLater(new Runnable(){
                public void run(){
                    
                     tangramFrame.mainPanel.repaint();
                }
            });  
  }catch(Exception e){
              System.err.println("ERROR REPAINTING MAZE "+e.getMessage().toString());
   }
}  

  /**
   * Processes messages that arrive from the server. The types and contents of these 
   * messages are used to determine appropriate updates to the local maze game.
   * @param mt
   */
  public void processTaskMove(MessageTask mt){
      
       if (mt instanceof MessageNewTangrams) {
           
           System.out.println("recieved MessageNewTangrams");
           if (mt instanceof MessageNewTangramsMatcher)
          {
              MessageNewTangramsMatcher mntm=(MessageNewTangramsMatcher)mt;
              Vector<SerialTangram> tangrams=mntm.tangrams;
              String setName=mntm.tangramSetName;
              
              tangramFrame.mainPanel.loadNext(tangrams,setName,null,'n');
              //tangramFrame.disableFrame();
          }
          else if (mt instanceof MessageNewTangramsDirectorA)
          {
              MessageNewTangramsDirectorA mnta=(MessageNewTangramsDirectorA)mt;
              Vector<SerialTangram> tangrams=mnta.tangrams;
              String setName=mnta.tangramSetName;
              TangramSequence sequence=mnta.sequence;
              tangramFrame.mainPanel.loadNext(tangrams, setName, sequence, 'A');
              //tangramFrame.disableFrame();
          }
          else if (mt instanceof MessageNewTangramsDirectorB)
          {
              MessageNewTangramsDirectorB mntb=(MessageNewTangramsDirectorB)mt;
              Vector<SerialTangram> tangrams=mntb.tangrams;
              String setName=mntb.tangramSetName;
              TangramSequence sequence=mntb.sequence;
              tangramFrame.mainPanel.loadNext(tangrams, setName, sequence, 'B');
              //tangramFrame.disableFrame();
          }
        }
        else if (mt instanceof MessageStartGame) {
            
            //not being used at the moment. The game starts as soon as new tangrams are recieved
         
            tangramFrame.enableFrame();
        }
        else if (mt instanceof MessageNextTangramPlaced){
            MessageNextTangramPlaced mntp=(MessageNextTangramPlaced)mt;
            int slotPlaced=mntp.getTargetSlotID();
            boolean directorMoveOn=mntp.directorMoveOn();
            tangramFrame.updateStatusTangramPlaced(mntp.getActiveDropSlot(), directorMoveOn);
        }
        else if (mt instanceof MessageTangramRevealed)
        {
            MessageTangramRevealed mtr=(MessageTangramRevealed)mt;
            
            int slotRevealed=mtr.getSlotID();
            System.out.println("Tangram revealed recieved " + slotRevealed);
            tangramFrame.updateStatusTangramRevealed(slotRevealed);
            
        }
        else if (mt instanceof MessageEndOfGame)
        {
            this.tangramFrame.disableFrame();
        }
            
            
            
            
          
  }
  public void tangramPlaced(int activeDropSlot, int sourceSlotID,int targetSlotID, boolean directorMoveOn, String tangramName)
  {
        MessageNextTangramPlaced mtp=new MessageNextTangramPlaced(cts.getEmail(), cts.getUsername(), activeDropSlot, sourceSlotID, targetSlotID, directorMoveOn, tangramName);
        cts.sendMessage(mtp);
  }
  
  public void tangramRevealed(int slotID, String tangramName)
  {
      MessageTangramRevealed mtr=new MessageTangramRevealed(cts.getEmail(), cts.getUsername(), slotID, tangramName);
      cts.sendMessage(mtr);
  }
  
  public void endOfCurrentTangramSet()
  {
      System.out.println("sending MessageEndOfCurTangramSet");
      MessageEndOfCurTangramSet mets=new MessageEndOfCurTangramSet(cts.getEmail(), cts.getUsername());
      cts.sendMessage(mets);
      
  }
  public void tangramClicked(String tangramName)
  {
      //called by Matcher frame
      
  }
  public void tangramHovered(String tangramName)
  {
      //called by Matcher frame
  
  }
  public void tangramDragged(String tangramName)
  {
      //called by Matcher frame
      
  }
  
  
  /**
   * Returns the String currently being displayed in the Maze Game window (distinct from the JChatFrame)
   * @return message displayed in the maze game window
   */
  public String getDisplayMessage() {
    return this.dispMessage;
  }

  /**
   * Displays the String in the Maze Game window
   * @param msg
   */
  public void setDisplayMessage(String msg) {
    dispMessage = msg;
    //jmf.jPanel1.paint(jmf.jPanel1.getGraphics());
    
  }

  /**
   * Called when all participants in maze game are on their respective goals. Selects and displays the next maze
   * in the Vector of stored mazes
   * @param i
   */
  

  private void resetWaitingForNextExperiment() {
    setDisplayMessage("Experiment Finished.");
    try {
      this.sleep(1000);
    }
    catch (Exception e) {}

  } 
  
  public void closeDown(){}
}
