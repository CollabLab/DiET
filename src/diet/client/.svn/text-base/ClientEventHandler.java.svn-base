package diet.client;

import java.awt.Toolkit;
import java.awt.event.KeyEvent;
import java.util.Date;
import java.util.Vector;

import javax.swing.text.AttributeSet;
import javax.swing.text.Style;

import client.ClientMazeGameComms;
import diet.debug.Debug;
import diet.message.Keypress;
import diet.server.CbyC.DocChange;
import diet.server.CbyC.DocInsert;
import diet.server.CbyC.DocRemove;
import diet.server.Conversation;
import javax.swing.text.StyleContext.NamedStyle;

/**
 * This is the intermediary between low-level exchange of messages between client and server (handled by ConnectionToServer)
 * and higher-level UI events handled by the JChatFrame chat window. 
 * <p> It handles both events generated by the chat window and also commands received from the server
 * 
 * <p> Some of the methods are associated with particular user interfaces. In particular, the methods pre-fixed with WYSIWYG
 * are associated with the "what you see is what you get" / character-by-character interfaces.
 * 
 * @author user
 */
public class ClientEventHandler {

    private JChatFrame jcf;
    private ConnectionToServer cts;
    /**
     * This records for each turn all keypresses. It is reset whenever the participant presses Enter/Return/Send
     */
    private Vector keyspressedSinceLastTextEntry = new Vector();
    /**
     * This records for each turn when the participant first started typing
     */
    long startOfTyping;
    /**
     * This records for each turn when the participant pressed Enter/Return/Send
     */
    boolean startOfTypingHasBeenRecorded = false;
    private boolean allowTextEntryToBeSentToServerAndAppendedToPane = false;
    public boolean participantIsEnteringControlCode;
    public boolean currentTurnBeingConstructedHasBeenBlocked = false;
    //int participantsOwnWindowForTextEntry=0;

    //private ClientSetupParameters
    public ClientEventHandler() {
        super();
        
        
        
    }

    /**
     * Associates this with ConnectionToServer which deals with low-level exchange of messages
     * @param cts
     */
    public void setConnectionToServer(ConnectionToServer cts) {
        this.cts = cts;
    }

    /**
     * Associates this with a Chat window interface 
     * @param jcf
     */
    public void setChatFrame(JChatFrame jcf) {
        this.jcf = jcf;
        DebugThread jcfdbg;  
        jcfdbg = new DebugThread(this); 
    }

    public JChatFrame getChatFrame(){
        return jcf;
    }
    
    /**
     * Appends text to the participant's chat window. Text usually contains
     * @param s
     * @param windowNumber
     */
    public  void appendWithCaretCheck(String prefix,String text, int windowNumber, int stylenumber ) {
        if(jcf instanceof JChatFrameMultipleWindowsWithSendButton){
            String s ="";
            String t ="";
            if(prefix!=null) s = s+ prefix;
            if(text!=null)t=t+text;
            jcf.appendWithCaretCheck(s+t, windowNumber);
            
        }
        else {
            if (prefix==null||prefix=="") {
                prefix ="";
            }
            else{
                prefix = prefix+": ";
            }
            if(text==null)text ="";
            jcf.appendWithCaretCheck(prefix, windowNumber, "h"+stylenumber);
            jcf.appendWithCaretCheck(text+"\n", windowNumber, "n"+stylenumber);

       }
    }

    /**
     * Retrieves text from chat window's text-entry field, does preliminary removal of white space, appends it to the local
     * client's chat window, sends the text to {@link ConnectionToServer} in order to be sent to the server, clears the local
     * timing / and keypress information associated with the turn and then clears the text-entry field.
     */
    public void sendButtonPressed() {
        if (allowTextEntryToBeSentToServerAndAppendedToPane) {
            String text = jcf.getTextEnteredInField();
            text = text.replaceAll("\n", "");
           if(jcf instanceof JChatFrameMultipleWindowsWithSendButtonWidthByHeight){
                jcf.appendWithCaretCheck(cts.getUsername()+ ": ", jcf.getParticipantsOwnWindow(), "hs");
                jcf.appendWithCaretCheck(text + "\n", jcf.getParticipantsOwnWindow(), "ns");
            }
            else{
                jcf.appendWithCaretCheck(cts.getUsername() + ": " + text + "\n", jcf.getParticipantsOwnWindow());
            }
            cts.sendChatText(text, startOfTyping, currentTurnBeingConstructedHasBeenBlocked, keyspressedSinceLastTextEntry);
            currentTurnBeingConstructedHasBeenBlocked = false;
            jcf.setTextEntryField("");
            clearKeypresses();
        }

    }

    /**
     * Retrieves text from chat window's text-entry field, does preliminary removal of white space, appends it to the local
     * client's chat window, sends the text to {@link ConnectionToServer} in order to be sent to the server, clears the local
     * timing / and keypress information associated with the turn and then clears the text-entry field.
     */
    public void returnPressed() {
	//System.out.println("return pressed");
        
        if(jcf instanceof JChatFrameSingleWindowCBYCWithEnforcedTurntaking)return;


        if (allowTextEntryToBeSentToServerAndAppendedToPane) {
            
            String text = jcf.getTextEnteredInField();
            text = text.replaceAll("\\p{Cntrl}", "");
            if(jcf instanceof JChatFrameMultipleWindowsWithSendButtonWidthByHeight){
                jcf.appendWithCaretCheck(cts.getUsername()+ ": ", jcf.getParticipantsOwnWindow(), "hs");
                jcf.appendWithCaretCheck(text + "\n", jcf.getParticipantsOwnWindow(), "ns");
            }
            else{
                jcf.appendWithCaretCheck(cts.getUsername() + ": " + text + "\n", jcf.getParticipantsOwnWindow());
            }
            cts.sendChatText((text), startOfTyping, currentTurnBeingConstructedHasBeenBlocked, keyspressedSinceLastTextEntry);
            currentTurnBeingConstructedHasBeenBlocked = false;
            jcf.setTextEntryField("");
            clearKeypresses();
        }
        else{
           System.exit(-3454);
        }   
    }

    /**
     * Clears the information stored for the turn being constructed
     */
    public void clearKeypresses() {
        startOfTypingHasBeenRecorded = false;
        startOfTyping = -400000;
        keyspressedSinceLastTextEntry.removeAllElements();
        keyspressedSinceLastTextEntry = new Vector();
    }

    /**
     * Processes each keypress associated with the chat tool window.
     * In the current implementation, any key pressed while pressing 
     * and holding down the "Ctrl key" is treated as not being associated
     * with turn-construction and is instead relayed to the TaskController (e.g
     * ClientMazeGameComms if it exists).
     *
     * @param e
     */
    public void keyPressFilter(KeyEvent e) {
       try{ 
        if (cts.cteh != null && cts.cteh instanceof ClientMazeGameComms) {
            ((ClientMazeGameComms)cts.cteh).relayKeypressToMazeFrame(e);
        }
        if (!allowTextEntryToBeSentToServerAndAppendedToPane) {
        	Toolkit.getDefaultToolkit().beep();
            return;
        }
        int i = e.getKeyCode();
        if (i == 17) {
            this.participantIsEnteringControlCode = true;
            this.jcf.setEditable(false);
            
        }
        if (this.participantIsEnteringControlCode) {
            if (i == 37 || i == 38 || i == 39 || i == 40) {
                
            }
        } else if (!participantIsEnteringControlCode) {
            if (!startOfTypingHasBeenRecorded) {
                startOfTypingHasBeenRecorded = true;
                startOfTyping = new Date().getTime();
            }
            //perform beep if there's a floor clash in the CByC interface
            if (this.jcf instanceof JChatFrameSingleWindowCBYCWithEnforcedTurntaking)
            {
            	JChatFrameSingleWindowCBYCWithEnforcedTurntaking jcfcbyc=(JChatFrameSingleWindowCBYCWithEnforcedTurntaking)jcf;
            	if ((jcfcbyc.docII.getState()==CBYCDocumentWithEnforcedTurntaking.othertyping) && jcfcbyc.docII.performBeepOnFloorClash()){
            		Toolkit.getDefaultToolkit().beep(); 
            		//diet.server.Conversation.printWSln("BEEP","KEYPRESSBEEP");
            	}
            }
            Keypress kp = new Keypress(i, new Date().getTime());
            keyspressedSinceLastTextEntry.addElement(kp);
            
             cts.sendClientIsTyping(kp, this.jcf.getTextEnteredInField().replaceAll("\\p{Cntrl}", ""));
             //cts.sendClientIsTyping(kp, ".....");
        }
       }catch (Exception e2){
           cts.sendErrorMessage(e2);
       }

    }

    /**
     * Detects whether the key being released is the "Ctrl" key. If yes, the
     * control sequence being relayed to the TaskController (e.g. ClientMazeGameComms) is
     * terminated. 
     * @param e
     */
    public void keyReleaseFilter(KeyEvent e) {
      try{  
        if (cts.cteh != null && cts.cteh instanceof ClientMazeGameComms) {
            ((ClientMazeGameComms)cts.cteh).relayKeyReleaseFilterToMazeFrame(e);
        }
        if (!allowTextEntryToBeSentToServerAndAppendedToPane) {
            return;
        }
        if (e.getKeyCode() == 17) {
            participantIsEnteringControlCode = false;
            this.jcf.setEditable(true);
        //System.out.println("go"+e.getKeyCode());

        }
        if (e.getKeyCode() == 10 & allowTextEntryToBeSentToServerAndAppendedToPane) {
            returnPressed();
        }
      }catch (Exception e2){
          cts.sendErrorMessage(e2);
      }
    }

    /**
     * Adds String to the WYSIWYG chat window at the specified position
     * @param windowNumber
     * @param replacementText
     * @param offset
     * @param length
     */
    public void wYSIWYGUpdateDocumentInsert(int windowNumber, String replacementText, int offset, int length) {
        jcf.wYSIWYGUpdateDocumentInsert(windowNumber, replacementText, offset, length);
    }

    /**
     * Removes text from the chat window at the specified position/length
     * @param windowNumber
     * @param offset
     * @param length
     */
    public void wYSIWYGUpdateDocumentRemove(int windowNumber, int offset, int length) {
        jcf.wYSIWYGUpdateDocumentRemove(windowNumber, offset, length);
    }

    public void wYSIWYGDocumentHasChanged(String textAtEndOfString, int offset) {
        try {
            //System.out.println("WYSIWYGCLEVENTHANDLER1");
            cts.sendChatTextWYSIWYG(textAtEndOfString, offset);
        //System.out.println("WYSIWYGIN CLEVENTHANDLER2");
        } catch (Exception e) {
            //EMUI.println(cts.getUsername(),"ERROR IN CLEVENTHANDLER");
        }
    //clearKeypresses();
    }

    /**
     * Invoked by the WYSIWYG interface when text is deleted at the specified offset/length
     * @param offset
     * @param length
     */
    public void wYSIWYGDocumentHasChangedRemove(int offset, int length) {
        try {
            cts.sendWYSIWYGDocumentHasChangedRemove(offset, length);
        //System.out.println("WYSIWYGIN CLEVENTHANDLER2");
        } catch (Exception e) {
            // EMUI.println(cts.getUsername(),"ERROR IN CLEVENTHANDLER");
        }
    }

    /**
     * Invoked by the WYSIWYG interface when text is inserted at the specified offset/length
     * @param text
     * @param offset
     * @param length
     */
    public void textEntryDocumentHasChangedInsert(String text, int offset, int length,String textInTextEntryWindow) {
        try {
            cts.sendWYSIWYGDocumentHasChangedInsert(text, offset, length, textInTextEntryWindow);
        //System.out.println("WYSIWYGIN CLEVENTHANDLER2");
        } catch (Exception e) {
            // EMUI.println(cts.getUsername(),"ERROR IN CLEVENTHANDLER");
        }
    }

    
    public void wYSIWYGDocumentHasChangedReplaceDEPRECATED(String text, int offset, int length) {
        try {
            cts.sendWYSIWYGDocumentHasChangedInsert(text, offset, length, "DEPRECATED");
        //System.out.println("WYSIWYGIN CLEVENTHANDLER2");
        } catch (Exception e) {
            // EMUI.println(cts.getUsername(),"ERROR IN CLEVENTHANDLER");
        }
    }
    
    
    
    
    /**
     * Invoked by the WYSIWYG chat window when cursor position and/or selection changes
     * @param startPos
     * @param finishPos
     */
    public void wYSIWYGCursorAndSelectionHasChanged(int startPos, int finishPos) {
        cts.sendCursorAndSelectionUpdateWYSIWYG(startPos, finishPos);
    //System.out.println("SENDING SELECTION "+startPos+" "+finishPos);
    }

    /**
     * Changes the position of the cursor and the selected text in the WYSIWYG chat window
     * @param windowNumber
     * @param startPos
     * @param finishPos
     */
    public void wWYSIWYGChangeCursorAndSelectionInWindow(int windowNumber, int startPos, int finishPos) {
        jcf.wYSIWYGChangeCursorAndSelection(windowNumber, startPos, finishPos);
    //System.out.println("RECEIVING SELECTION "+startPos+" "+finishPos);
    }

    /**
     * Determines whether the display of cursor position and text highlighting is permitted in chat window
     * @param windowNumber
     * @param cursorIsDisplayed
     * @param selectionIsDisplayed
     */
    public void wWYSIWYGCsetCursorAndSelectionrAreDisplayed(int windowNumber, boolean cursorIsDisplayed, boolean selectionIsDisplayed) {
        jcf.wYSIWYGsetCursorAndSelectionAreDisplayedWYSIWYG(windowNumber, cursorIsDisplayed, selectionIsDisplayed);
    }

    /**
     * Sets text and colour of the text (black/red) in the status bar window. Also determines whether text entry is subsequently
     * permitted.
     * @param windowNumber
     * @param label
     * @param textIsInRed
     * @param setWindowEnabled
     */
    public void setLabelAndTextEntryEnabled(int windowNumber, String label, boolean textIsInRed, boolean setWindowEnabled) {
    	allowTextEntryToBeSentToServerAndAppendedToPane=setWindowEnabled;
        jcf.setLabelAndTextEntryEnabled(windowNumber, label, textIsInRed, setWindowEnabled);
        
        
        
    }

    /**
     * Sets String in Status window (black/red)
     * @param windowNumber
     * @param label
     * @param textIsInRed
     */
    public void setLabel(int windowNumber, String label, boolean textIsInRed) {


        jcf.setLabel(windowNumber, label, textIsInRed);
    }

    /**
     * Called by single window WYSIWYG chat window to request the conversational floor.
     * @param offsetFrmRight
     * @param txt
     */
    public void wYSIWYGrequestTypingUnhindered(int offsetFrmRight, String txt) {
        cts.sendWYSIWYGTypingUnhinderedRequest(offsetFrmRight, txt);
    }

    /**
     * Relays from server whether request for conversational floor has been permitted / client has lost floor
     * (e.g. through timeout determined by server)
     *  
     * 
     * @param status
     * @param msg
     */
    public void wWYSIWYGChangeInterceptionStatus(int status, String msg) {
        jcf.wWYSIWYGChangeInterceptStatus(status, msg);
    }
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
    
    public void cBYCrequestTypingUnhindered(int offsetFromRight,String textTyped,String eString,int eStart,int eFinish){
        cts.sendCBYCTypingUnhinderedRequest(offsetFromRight, textTyped,eString,eStart,eFinish);
    }
    
     public void cBYCDocumentHasChangedRemove(int offset, int length,String elementString,int elementStart,int elementFinish,int docSize) {
         cts.sendCBYCDocumentHasChangedRemove(offset, length,elementString, elementStart,elementFinish,docSize);    
    }

     
     
     
     
    public void cBYCDocumentHasChangedInsert(String text, int offset, Style attr,String elementString,int elementStart,int elementFinish,int docSize) {
        if(Debug.showErrorsForMacIntegration)Conversation.printWSln("FONTTYPE",((NamedStyle)attr).getName());
        //Conversation.printWSln("FONTTYPE", attr.NameAttribute+" --"+attr.getAttributeNames()+" ---"+attr.toString());


       // cts.sendCBYCDocumentHasChangedInsert(text, offset,attr,elementString, elementStart,elementFinish,docSize);
        cts.sendCBYCDocumentHasChangedInsert(text, offset,((NamedStyle)attr).getName(),elementString, elementStart,elementFinish,docSize);
    }

    
    public void cBYCDocumentHasChangedReplace(String text, int offset, int length,String elementString,int elementStart,int elementFinish,int docSize) {
        if(length>0){
            cts.sendCBYCDocumentHasChangedRemove(offset, length,elementString, elementStart,elementFinish,docSize); 
        }
        if(text.length()>0){
            cts.sendCBYCDocumentHasChangedInsert(text, offset, length,elementString, elementStart,elementFinish,docSize);
        }
        
    }
    
    public void cBYCStateHasChanged(int oldState,int newState,long id){
        cts.cBYCStateHasChanged(oldState,newState,id);
    }
    
    public void cBYCChangeInterceptionStatus(int status,DocInsert prefix,long id){
        jcf.cBYCChangeInterceptionStatus(status, prefix,id);
    }
          
    public void cBYCDocChangeToClient(DocChange dc){
        if(dc instanceof DocInsert){
            DocInsert di = (DocInsert)dc;
            jcf.cBYCUpdateDocumentInsert(0, di.getStr(), di.offs, di.getStr().length(), di.getAttrSet());
        }
        else if(dc instanceof DocRemove){
            DocRemove dr = (DocRemove)dc;
            jcf.cBYCUpdateDocumentRemove(0, dr.getOffs(), dr.getLen());
        }
    }
    public void cBYCCursorAndSelectionHasChanged(int startPos, int finishPos) {
       
    }
   //-----------------------------------------------------------------------------------------------------------
   //-----------------------------------------------------------------------------------------------------------
    public void withinTurnRequestInsert(int offset, String str,AttributeSet a){
        cts.withinTurnRequestInsert(offset, str, a);
    }
    public void withinTurnRequestRemove(int offset, int len){
        cts.withinTurnRequestRemove(offset, len);
    }
    public void withinTurnRequestReplace(int offset, String str,int len,AttributeSet a){
        cts.withinTurnRequestReplace(offset, str, len, a);
    }
    public void withinTurnCursorAndSelectionHasChanged(int startPos, int finishPos) {
        cts.withinTurnSendCursorAndSelectionUpdate(startPos, finishPos);
    }
    public void withinTurnForceDocumentInsert(int windowNumber,String text,int offset,int length,Object attributeSetOrString){
        jcf.withinTurnUpdateDocumentInsert(windowNumber, text, offset, length, attributeSetOrString);
            
    }
    public void withinTurnForceDocumentRemove(int windowNumber,int offset,int length){
        jcf.withinTurnUpdateDocumentRemove(windowNumber, offset, length);
    }
    public void withinTurnChangeCursorAndSelectionInWindow(int windowNo, int start,int finish){
        jcf.withinTurnChangeCursorAndSelection(windowNo, start, finish);
    }
    public void withinTurnSetCursorAndSelectionAreDisplayed(int windowNo, boolean cursorIsDisplayed,boolean selectionIsDisplayed){
        jcf.withinTurnSetCursorAndSelectionAreDisplayed(windowNo, cursorIsDisplayed,selectionIsDisplayed);
    }
    
    public ConnectionToServer getCts() {
        return this.cts;
    }

    
    public void changeInterfaceProperties(int newInterfaceproperties){
        if(newInterfaceproperties==diet.message.MessageChangeClientInterfaceProperties.disableRETURNANDSEND_enableTEXTENTRY){
                    this.allowTextEntryToBeSentToServerAndAppendedToPane=false;
    }
        else if(newInterfaceproperties==diet.message.MessageChangeClientInterfaceProperties.enableRETURNANDSEND_enableTEXTENTRY){
                    this.allowTextEntryToBeSentToServerAndAppendedToPane = true;    
        }
        jcf.changeInterfaceProperties(newInterfaceproperties);
        
    }
    
    
    
    /**
     * Closes down the client, freeing resources
     */
    public void closeDown() {
        try {
            jcf.setVisible(false);
            jcf.closeDown();
            jcf.dispose();
            this.jcf=null;
            cts = null;
            System.err.println("ClientEventHandler closing down");
        } catch (Exception e) {
        }
    }
}
